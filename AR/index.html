<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>VFI Model — Image‑Tracked WebAR</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { position: fixed; inset: 0; display: grid; place-items: center; background:#000; }
    #panel {
      position: fixed; left: 0; right: 0; bottom: 0; padding: 12px 12px 14px;
      background: rgba(0,0,0,.55); backdrop-filter: blur(6px);
      color: #fff; display: grid; row-gap: 6px; z-index: 10;
    }
    #panel.hidden { display: none; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button, .chip {
      appearance: none; border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.1); color: #fff; padding: 8px 12px; border-radius: 999px;
      font: inherit; cursor: pointer;
    }
    button:disabled { opacity:.5; cursor: not-allowed; }
    .chip { display:inline-flex; align-items:center; gap:8px; }
    .chip input { accent-color: #6cf; width: 16px; height:16px; }
    #status { position: fixed; top: 10px; left: 10px; right: 10px; color: #fff; text-shadow: 0 1px 2px #000; z-index: 10;}
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  </style>

  <!-- Map bare module imports that MindAR uses -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="app">
    <div id="status">Ready. Tap “Start AR” and point at the target image.</div>
    <div id="panel">
      <div class="row">
        <button id="startBtn">▶︎ Start AR</button>
        <button id="flipBtn">↺ Flip Camera</button>
        <button id="showAll">Show all layers</button>
        <button id="hideAll">Hide all</button>
      </div>
      <div id="layerToggles" class="row" aria-label="Layer toggles"></div>
    </div>
  </div>

  <!-- Your AR app as an ES module -->
  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from './libs/mindar-image-three.prod.js';

    // ---- Config ----
    const TARGETS_FILE = 'targets.mind';
    const MODEL_WIDTH_M = 0.15; // 150mm physical width mapped to the target
    const LAYERS = [
      { id:'Aerial + massing',       src:'layers/1.png', width: MODEL_WIDTH_M },
      { id:'Grass + roads (render)', src:'layers/2.png', width: MODEL_WIDTH_M },
      { id:'Linework (B/W)',         src:'layers/3.png', width: MODEL_WIDTH_M },
      { id:'Simplified color plan',  src:'layers/4.png', width: MODEL_WIDTH_M },
      { id:'Blank parcel mask',      src:'layers/5.png', width: MODEL_WIDTH_M }
    ];

    // ---- DOM ----
    const startBtn = document.getElementById('startBtn');
    const flipBtn  = document.getElementById('flipBtn');
    const showAllBtn = document.getElementById('showAll');
    const hideAllBtn = document.getElementById('hideAll');
    const layerToggles = document.getElementById('layerToggles');
    const statusEl = document.getElementById('status');
    const panelEl = document.getElementById('panel');

    // ---- State ----
    let mindar, renderer, scene, camera, anchor, overlayRoot;
    let currentFacingMode = 'environment';
    const meshes = new Map();

    function status(msg){ statusEl.textContent = msg; }

    function enableButtons(enabled){
      [flipBtn, showAllBtn, hideAllBtn].forEach(b => b.disabled = !enabled);
    }
    enableButtons(false);

    function disposeMindAR(){
      if(mindar){
        try { mindar.stop(); mindar.renderer?.dispose?.(); } catch(e){}
      }
      mindar = null; renderer = null; scene = null; camera = null; anchor = null; overlayRoot = null;
      meshes.clear();
    }

    function makePlaneFromTexture(tex, widthMeters){
      const ar = tex.image.width / tex.image.height;
      const geo = new THREE.PlaneGeometry(widthMeters, widthMeters / ar);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
      const mesh = new THREE.Mesh(geo, mat);
      // Place so that the plane sits centered on the target
      mesh.position.set(0, 0, 0);
      mesh.rotation.x = -Math.PI/2; // lay flat on target
      return mesh;
    }

    async function loadTexture(url){
      return new Promise((resolve, reject) => {
        new THREE.TextureLoader().load(url, tex => {
          tex.encoding = THREE.sRGBEncoding;
          tex.needsUpdate = true;
          resolve(tex);
        }, undefined, err => reject(err));
      });
    }

    function buildLayerUI(){
      layerToggles.innerHTML = '';
      for(const { id } of LAYERS){
        const label = document.createElement('label');
        label.className = 'chip';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = true;
        cb.dataset.id = id;
        cb.addEventListener('change', () => {
          const m = meshes.get(id);
          if(m) m.visible = cb.checked;
        });
        label.appendChild(cb);
        label.appendChild(document.createTextNode(id));
        layerToggles.appendChild(label);
      }
      showAllBtn.onclick = () => { for(const [id,m] of meshes) { m.visible = true; const cb = layerToggles.querySelector('input[data-id="'+id+'"]'); if(cb) cb.checked = true; } };
      hideAllBtn.onclick = () => { for(const [id,m] of meshes) { m.visible = false; const cb = layerToggles.querySelector('input[data-id="'+id+'"]'); if(cb) cb.checked = false; } };
    }

    async function initAR(){
      try{
        enableButtons(false);
        panelEl.classList.add('hidden');
        status('Requesting camera…');

        disposeMindAR();

        mindar = new MindARThree({
          container: document.body,
          imageTargetSrc: TARGETS_FILE,
          uiScanning: true,
          uiLoading: 'yes',
          filterMinCF: 0.0001,
          filterBeta: 0.001,
          maxTrack: 1,
          warmupTolerance: 5,
          // Camera
          capture: currentFacingMode, // 'environment' | 'user'
        });

        ({ renderer, scene, camera } = mindar);
        const light = new THREE.HemisphereLight(0xffffff, 0x222222, 1.1);
        scene.add(light);

        // Anchor on image target #0
        anchor = mindar.addAnchor(0);
        overlayRoot = new THREE.Group();
        anchor.group.add(overlayRoot);

        // Load & place layers
        status('Loading layers…');
        buildLayerUI();
        for(const { id, src, width } of LAYERS){
          const tex = await loadTexture(src);
          const mesh = makePlaneFromTexture(tex, width);
          overlayRoot.add(mesh);
          meshes.set(id, mesh);
        }

        // Start AR
        await mindar.start();
        status('Point your camera at the target.');
        enableButtons(true);

        // Render loop
        const onFrame = () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.render(scene, camera);
          requestAnimationFrame(onFrame);
        };
        onFrame();

      }catch(err){
        status('⚠️ ' + (err?.message || err));
        alert('Error starting AR: ' + (err?.message || err));
        console.error(err);
        panelEl.classList.remove('hidden');
        enableButtons(false);
      }
    }

    // UI events
    startBtn.addEventListener('click', initAR);

    flipBtn.addEventListener('click', async () => {
      currentFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
      await initAR();
    });

    document.addEventListener('visibilitychange', async () => {
      if (document.visibilityState === 'hidden') {
        try { mindar?.pause(); } catch(e){}
      } else {
        try { mindar?.resume(); } catch(e){}
      }
    });

    // If user loaded page over http or file:, explain why camera won't work
    if (location.protocol !== 'https:') {
      status('This page must be served over HTTPS for camera access.');
    }
  </script>
</body>
</html>
